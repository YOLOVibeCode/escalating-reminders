# Escalating Reminders - AI Coding Rules

ROLE: engineer STRICT=true

## Stack
Next.js 15 | React 19 | TypeScript 5 strict | Tailwind 4 | NestJS | Prisma 6 | Jest | Playwright | pnpm monorepo

## Response Format
- Code + 3-line max docstring
- No explanation unless asked
- If >50 lines: modularize into helpers
- If ambiguous: 2 implementations + 1-line tradeoff each
- Assume experienced user—skip basics

## Before Writing
1. Search codebase—reuse existing patterns
2. Check for `architecture-checklist.md` / `AI_REFACTOR_PLAN.md`
3. If API endpoint: confirm route + Zod schema exists
4. List edge cases you'll handle

## Code Standards
- TypeScript strict, no `any`
- Errors: throw (not return null)
- No hardcoded values—use env/config
- No static mocks—API-driven data only
- No console.log—use Pino logger
- KISS + YAGNI + DRY × SOLID

## Mandates (ENFORCE STRICTLY)

### M1: No Static Mocks
```typescript
// ❌ REJECT
const mockUsers = [{ id: '1', name: 'Test' }];
import mockData from './mocks/users.json';

// ✅ REQUIRE
import { apiRequest } from '@/lib/api-client';
const users = await apiRequest<User[]>('/users');
```

### M2: Interface Segregation
```typescript
// ❌ REJECT - god interface
interface IUserService { /* 20+ methods */ }

// ✅ REQUIRE - granular
interface IUserReader { getById(): User }
interface IUserWriter { create(): User }
```

### M3: Event-Driven Communication
```typescript
// ❌ REJECT - direct coupling
reminderService.notifyEscalation(reminder);

// ✅ REQUIRE - event bus
eventBus.emit('reminder.escalated', { reminderId, level });
```

### M4: Type Safety
- Zero `any` types—use `unknown` or generics
- TypeScript `strict: true`
- Zod schemas for all API inputs

### M5: Repository Pattern
```typescript
// ❌ REJECT - direct Prisma in services
const user = await prisma.user.findUnique({ where: { id } });

// ✅ REQUIRE - repository abstraction
const user = await this.userRepository.findById(id);
```

## Project Patterns (MUST follow)
| Pattern | Implementation |
|---------|---------------|
| Services | Segregated interfaces (IXReader, IXWriter), DI via constructor |
| Repositories | Prisma-based, read/write separation |
| API Client | Use `apiRequest<T>` from `lib/api-client.ts` |
| Events | Use `DataEventBus` for cross-component communication |
| Validation | Zod schemas for all inputs |
| Middleware | Auth → Validation → Rate-limit → Handler → Error |
| Monorepo | `packages/@er/*` for shared code, `apps/*` for implementations |

## CLI Output
No emojis in: shell scripts, terminal commands, CI/CD, logs, error messages
Allowed in: .md files, React components, code comments, commits

## Safety Rails
- Never delete/refactor/optimize without OK
- Preserve comments & existing style
- Assume code has purpose
- Present simpler alternative with confidence (1–10) before edits

## Self-Check
```
[ ] No placeholder code
[ ] Edge cases handled
[ ] Matches codebase patterns
[ ] Types complete, Zod schema if API
[ ] STRICT mode honored
[ ] No static mocks
[ ] Uses repository pattern
[ ] Events for cross-component communication
```

## Quick Reference
```bash
# Dev
pnpm dev                # Start all apps
pnpm dev:api            # API only (port 3810)
pnpm dev:web            # Web only (port 3800)

# Testing
pnpm test               # Jest unit tests
pnpm test:e2e           # Playwright E2E

# Database
pnpm db:migrate         # Run migrations
pnpm db:seed            # Seed data
```

## Violation Response
When violation detected:
1. REJECT with mandate number
2. Show bad code vs good code
3. Reference relevant .md file
4. Provide fix instruction

ROLE: engineer STRICT=true


---

## UI AUTOMATION REQUIREMENTS (CRITICAL)

All UI components MUST be automation-friendly for Playwright, browser automation, and MCP testing.

### Data Test IDs (MANDATORY)

Add `data-testid` attributes to ALL interactive elements and key containers:

| Element Type | Pattern | Example |
|-------------|---------|---------|
| Buttons | `data-testid="btn-{action}"` | `data-testid="btn-submit"`, `data-testid="btn-cancel"` |
| Forms | `data-testid="form-{name}"` | `data-testid="form-login"` |
| Inputs | `data-testid="input-{field}"` | `data-testid="input-email"` |
| Links | `data-testid="link-{destination}"` | `data-testid="link-dashboard"` |
| Modals | `data-testid="modal-{name}"` | `data-testid="modal-confirm"` |
| Tables | `data-testid="table-{name}"` | `data-testid="table-users"` |
| Table Rows | `data-testid="row-{identifier}"` | `data-testid="row-user-123"` |
| Cards | `data-testid="card-{name}"` | `data-testid="card-profile"` |
| Dropdowns | `data-testid="dropdown-{name}"` | `data-testid="dropdown-status"` |
| Checkboxes | `data-testid="checkbox-{name}"` | `data-testid="checkbox-agree"` |

### Semantic HTML (MANDATORY)

- Use proper semantic elements (`<button>`, `<a>`, `<form>`, `<input>`) instead of divs with click handlers
- Use `<button type="button">` for actions, `<button type="submit">` for form submissions
- Use `<a href>` for navigation, not buttons with onClick navigation

### Accessible Labels (MANDATORY)

- Include `aria-label` for elements without visible text
- Use proper `<label htmlFor="id">` elements for form inputs
- Add `aria-describedby` for error messages linked to inputs

### Stable Selectors (MANDATORY)

- NEVER rely on auto-generated class names (CSS-in-JS hashes) as primary selectors
- ALWAYS use `data-testid` for test targeting
- Avoid using indexes or nth-child selectors

### Loading & Error States (MANDATORY)

- Add `data-loading="true|false"` attribute for async states
- Use `data-testid="loading-{component}"` for loading indicators
- Use `data-testid="error-{field}"` for validation/error messages
- Use `data-testid="empty-{component}"` for empty states

### Example Component:

```tsx
<form data-testid="form-login" onSubmit={handleSubmit}>
  <div>
    <label htmlFor="email">Email</label>
    <input
      id="email"
      data-testid="input-email"
      type="email"
      aria-describedby="email-error"
    />
    {errors.email && (
      <span id="email-error" data-testid="error-email" role="alert">
        {errors.email}
      </span>
    )}
  </div>
  
  <button
    type="submit"
    data-testid="btn-submit-login"
    data-loading={isLoading}
    disabled={isLoading}
    aria-label="Submit login form"
  >
    {isLoading ? 'Signing in...' : 'Sign In'}
  </button>
</form>
```

### Self-Check for UI Automation:

- [ ] All interactive elements have `data-testid`
- [ ] Forms use semantic HTML elements
- [ ] Inputs have associated labels
- [ ] Loading states are indicated with `data-loading`
- [ ] Error messages have `data-testid="error-*"`
- [ ] No reliance on generated CSS classes for testing

